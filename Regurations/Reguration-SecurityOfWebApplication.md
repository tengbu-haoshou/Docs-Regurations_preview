# Web アプリケーションセキュリティ規約

Web アプリケーションセキュリティの品質の向上・維持を狙う。<br>

## 目次

**1\. HTTP リクエスト時のセキュリティ**<br>
**2\. データベース読み書き時のセキュリティ**<br>
**3\. HTTP レスポンス時のセキュリティ**<br>
**4\. ミドルウェアのセキュリティ**<br>
**5\. アカウントのセキュリティ**<br>
**6\. 業務上のセキュリティ**<br>
**7\. その他の雑多なセキュリティ**<br>

## 1. HTTP リクエスト時のセキュリティ

リクエストデータが正しいかの検査を行うこと。<br>

* SQL インジェクション、コマンドインジェクション、ディレクトリトラバーサル、HTTP インジェクション、メールヘッダーインジェクションを防止するために、リクエストヘッダーやリクエストボディのデータに対してバリデーションによる検査を行うこと。
* CSRF（Cross Site Request Forgery）攻撃を緩和するために、更新画面の PUT、POST、DELETE リクエストでは、ブラウザー側では CSRF トークン送付、サーバー側では CSRF トークンの検証を行うこと。

## 2. データベース読み書き時のセキュリティ

データ暗号化・復号化を考慮したり、特殊文字を考慮したりすること。

* 可能であれば、データベースファイルの持ち出しでのデータ漏洩を防止するために、透過データ暗号化（TDE：Transparent Data Encryption）を採用すること。
* SQL インジェクションを防止するために、基本的に“?”（動的パラメーター）を使用すること。例えば、MyBatis において “WHERE USER_NAME = #{userName}” を使用すること（“WHERE USER_NAME = \${userName}” を使用してはならない）。
* LIKE の全件検索や後方一致検索による性能劣化を防止するため、LIKE の文字列を検査したり、ESCAPE を追加したりすること。
* 重要な文字列（パスワード、住所、電話番号、フォルダー名等）は、アプリケーション側で AES による暗号化・復号化を行うこと。
* データに特殊文字が含まれ、その特殊文字をデータベース保存する場合は、データベース書込み時にエンティティ化（\&gt;、\&lt; 等）を行うべきか、読み込み時にエンティティ化（\&gt;、\&lt; 等）を行うべきかを検討すること。

## 3. HTTP レスポンス時のセキュリティ

レスポンスデータを正しく返却すること。<br>

* XSS（Cross Site Scripting）攻撃を防止するために、レスポンスヘッダーやレスポンスボディのデータに対して特殊文字のエンティティ化（\&gt;、\&lt; 等）による無効化を行うこと。例えば、Thymeleaf において “th:text="\${value}"”を使用すること（“th:utext="\${value}"” を使用してはならない）。
* CSRF 攻撃を緩和するために、更新画面向けに CSRF トークンを返却すること。
* ブラウザー挙動の悪用を防止するために、Web フレームワークまたはアプリケーションでレスポンスヘッダーに設定を施すこと。

    ``` Response Header:レスポンスヘッダー
    Content-type: .../...; charset=UTF-8
    Cache-Control: private, no-store, no-cache, max-age=0, must-revalidate
    Expires: 0
    Set-Cookie: ...; Secure; HttpOnly;
    Pragma: no-cache
    Strict-Transport-Security: max-age=31536000; includeSubDomains
    X-Content-Type-Options: nosniff
    X-Frame-Options: SAMEORIGIN
    X-XSS-Protection: 1; mode=block
    ```

    Content-Type: text/html; charset=UTF-8<br>
    文字コードを正しく指定することで誤動作を防止する。<br>

    Set-Cookie: ...;Secure; HttpOnly;<br>
    HttpOnly とは、JavaScript から Cookie を読み込ませないようにする。<br>
    Secure とは、HTTPS のときだけ、この Cookie を送付させるようにする。<br>
    Domain や Path は、よく考えて使用すること。ルートのドメイン配下から子のパスの Cookie が参照できてしまうため。<br>

    X-Content-Type-Options: nosniff<br>
    ファイルの内容を Content-Type 属性から判断させる。<br>
    ファイルダウンロード時にファイル形式をブラウザに誤認させて JavaScript を実行させてしまうような攻撃（XSS 攻撃）を防止することができる。

    X-Frame-Options: SAMEORIGIN<br>
    コンテンツが他のサイトに埋め込まれないよう保証することで、クリックジャッキング攻撃を防止する。<br>

    X-Xss-Protection: 1; mode=block<br>
    ブラウザーの XSS フィルター制御。<br>
    1; mode=blockは、有効（表示の完全な停止）を意味する。緩和させる程度。<br>
    反射型 XSS（攻撃者が用意したURLにアクセスした時に発生する XSS のこと）を検知したときに、ページをレンダリング（処理）しない。<br>

* Web フレームワークが URL に セション ID を設定する場合、その URL での設定を外して、レスポンスヘッダー上に“Set-Cookie: SESSION_ID=xxxxx; Secure: HttpOnly”の形式で設定するように修正することで、セションハイジャックを緩和する。<br>

## 4. ミドルウェアのセキュリティ

レスポンスデータに攻撃のヒントとなるような文字列を出力しないようにすること。例えば、<br>

* Web サーバーまたは Web フレームワークがレスポンスヘッダーに “Server: {ミドルウェア名}-{バージョン番号}” といったもの（他には “x-powered-by:” など）を付加する場合は、それを付加しないように設定すること。
* レスポンスボディに Java クラッシュ時のスタックログを出力しないようにすること。

## 5. アカウントのセキュリティ

アカウント制御の機能を実装すること。<br>

* 初期パスワード、パスワード有効期間、パスワードミス回数オーバー時のアカウントロックなどを実装することで、ブルートフォース攻撃（ユーザー ID やパスワードの総当たりを行う）を緩和すること。
* パスワードは、大文字、小文字、英数字、記号の混合、また8文字以上とするなどの仕組みを実装すること。
* ログイン失敗時は、あえて細かいメッセージを出力しないこと。せいぜい “ユーザー ID またはパスワードに誤りがあります。” 程度にとどめること。細かいメッセージ、例えば“パスワードは 8文字以上を指定してください。” と出してしてしまうと、攻撃のヒントを与えることになってしまう（左記の場合、8文字以上のパスワードアタックをすればよいというヒントを与えることになる）。
* ユーザー ID 追加・変更・削除、ユーザーのログイン・ログアウトについて、アクセスログを取る仕組みを実装すること。アクセスログは、毎日ローテーションして最低 180日間保存などする。
* 必要に応じて、アイドルセションタイムアウトを実装すること。

## 6. 業務上のセキュリティ

業務機能として、アクセス制御の機能を実装すること。<br>

* スーパー管理者、パワーユーザー、業務ＸＸＸＸ作業ユーザー、業務ＸＸＸＸ承認ユーザーなど、細かいアカウントの設計を行うこと。
* 必要であれば、アプリケーションログを取る仕組みを実装すること。アプリケーションログは、毎日ローテーションして最低 180日間保存などする。

## 7. その他の雑多なセキュリティ

* 攻撃のヒントを与えないようにするために、ウェルカム画面やアバウト画面などに、使用している技術名やそのバージョン番号などを記述しないこと。
* クリックジャッキング攻撃を防止するために、できるだけ &lt;iframe&gt; タグは使用しないほうがよい。

<div style="text-align: right;">- 以上 -</div>
